#include <stdio.h>
#include <string.h>
#include <malloc.h>
#include <time.h>
#include <math.h>
#include "NWI.h"

// Main
#define DEBUG
#define ARG_NUM		2 // Extra argument count -v, -hex
#define BUF_SIZE	128
#define HEX_SIZE	8
#define LINE_SIZE	((HEX_SIZE * 2) + 3)
#define DEF_SIZE	64

#define MAX_PARAMS	8
#define MAX_INSTS	2
#define FORMAT_BUF	16

// Sections
#define SEC_NUM		3 // Number of Sections
#define SEC_TEXT	0 // Program Section
#define SEC_DATA	1 // Initialized data Section
#define SEC_BSS		2 // Uninitialized data Section

// File Generation
#define FNAME_MEM_EXT	"_mem"
#define MIF				0
#define HEX				1

// MIF Generation
#define MIF_PREFIX		"-- MIF file generated by NWI compiler\n"
#define MIF_TIMESTAMP	"-- Date: %02d.%02d.%d\n-- Time: %02d:%02d:%02d\n"
#define MIF_WIDTH		"WIDTH = %d;\n"
#define MIF_DEPTH		"DEPTH = %d;\n"
#define MIF_ADR_RADIX	"ADDRESS_RADIX = %s;\n"
#define MIF_DATA_RADIX	"DATA_RADIX = %s;\n"
#define MIF_SETTINGS	"WIDTH = %d;\nDEPTH = %d;\nADDRESS_RADIX = %s;\nDATA_RADIX = %s;\n"
#define MIF_RADIX_HEX	"HEX"
#define MIF_RADIX_DEC	"DEC"
#define MIF_RADIX_BIN	"BIN"
#define MIF_LINE		"%02X:%.*X;\n"
#define MIF_INIT_MEM	"[%02X..%02X]:00;\n"
#define MIF_START		"CONTENT BEGIN\n"
#define MIF_END			"END;"

// HEX Generation
#define HEX_LINE		":%02X%04X%02X%.*X%02X\n"// Byte Count, Address, Type, System size, Data, Checksum
#define HEX_LINE_TERM	":00000001FF\n"
#define HEX_TYPE_DATA	0
#define HEX_TYPE_TERM	1
#define HEX_TYPE_SEG	2

typedef struct out {
	char code;
	char line_str[BUF_SIZE], file[BUF_SIZE];
	unsigned int line, mem_len;
} out_t;

typedef struct section {
	int index;
	unsigned int len;
	char pos;
} section_t;

typedef struct sections {
	section_t sects[SEC_NUM];
	char sec_pos[SEC_NUM];
	char valid_sects;
	unsigned int size;
} sections_t;

typedef struct adr {
	unsigned int adr;
	char name[FORMAT_BUF];
} adr_t;

typedef struct macro {
	int val;
	char name[FORMAT_BUF];
} macro_t;

typedef struct slot {
	unsigned int adr;
	unsigned char space;
} slot_t;

// Input File processing
static int getFileLength(char *fname);
static int isFileTypeValid(char *file, char *type);
static out_t processFile(char *file_name, char *** data, unsigned int * data_size, char *** mem, unsigned int * mem_size, char hex, char verbose);
static out_t filterFile(char *fname, char *output[], char *incs[], unsigned int *inc_num, macro_t * macros, unsigned int *macro_num, char verbose);
static void processLine(char *line);
static int preprocessor(char *line, char *includes[], unsigned int *inc_num, macro_t * macros, unsigned int * macro_num);
static int processCommand(char *cmd, adr_t *adrs, unsigned int *adr_num, unsigned int *cmpl, unsigned int *cmpl_num, var_t *vars, unsigned int *var_num, macro_t * macros, unsigned int * macro_num);
static int processVariable(char *line, var_t *vars, unsigned int *var_num, slot_t *slots, unsigned int *mem_pnt, unsigned int *slot_num);

// Output File processing
static int generateMIF(char *fname, char *data[], unsigned int line_num, char *mem[], unsigned int mem_len, char verbose);
static int generateHEX(char *fname, char *data[], unsigned int line_num, char *mem[], unsigned int mem_len, char verbose);
static int getMemFileName(char *fname, char *fmemname, char hex);
static unsigned char hexChecksum(int byteNum, unsigned int adress, int type, int data);

// Addresses
static int searchAddress(char *line, int line_num, adr_t *adrs, unsigned int *adr_book_size);
static int isAddressValid(adr_t *adr_book, unsigned int adr_book_size, char *address);
// Sections
static int isSection(char *line);
static int searchSection(char *line, int line_num, sections_t *sects, char *last_sec, unsigned int sec_len, char sec_cnt, char *chk_sects);
static int findSections(out_t *output, char *text[], sections_t *sects);
static int mergeSections(sections_t *dest, sections_t *src, char **dest_txt, char **src_txt);
static int getDeadSpace(char **text);
// Variables
static int findVarAdr(var_t *variable, slot_t *slots, unsigned int *slot_num, unsigned int *mem_pnt);
static unsigned char getVarSize(int var_type);
// Macros
static int isMacroValid(macro_t *macros, unsigned int macro_num, char *macro);

volatile char *file_name = NULL, *name = NULL, *type = NULL;

static const char illegalChars[] = "!#$%&()*+/<=>?@\^{|}~";
// Preprocessor tags
static const char *preproc_tags[] = { "include", "define", NULL };
// Variable types
static const char *var_types[] = { "db", "dw", "dd", "dq", NULL };//, "dt"
// BSS types
static const char *bss_types[] = { "resb", "resw", "resd", "resq", NULL };//, "rest"

int main(int argc, char *args[]){
	
	if (argc > 2) {
		// Output name index
		char arg_indexes[ARG_NUM] = {-1};
		
		// Check if Verbose output is enabled
		char verbose_index, verbose = 0;
		arg_indexes[0] = getStringIndex("-v", args);
		if (arg_indexes[0] != -1) verbose = 1;
		
		// Check if Hex generation is selected
		char hex_index, hex = 0;
		arg_indexes[1] = getStringIndex("-hex", args);
		if (arg_indexes[1] != -1) hex = 1;
		
		// Store argument
		file_name = malloc(strlen(args[1]) + 1);
		strcpy(file_name, args[1]);
		
		if (verbose)printf("File: %s\nSystem: %s\n\n", args[1], args[2]);

		// Check file type
		if (isFileTypeValid(args[1], "asm")) {
			printf("Wrong file Type!");
			return -1;
		}
		// Load system
		if (loadSystem(args[2])) {
			printf("Invalid system!\n");
			return -1;
		}
		// Print System Information
		if (verbose)printf("Bus size: %d\nData size: %u\nMemory Type: %s\n\n", SYS_BUS, SYS_SIZE, SYS_MEM ? "Harward" : "Princeton");
		
		// Measure compile start clock
		clock_t start = clock();
		
		// Process File
		out_t output;
		unsigned int compiled_size = DEF_SIZE, mem_size = DEF_SIZE;
		char **compiled_data = malloc(compiled_size * sizeof(char*));
		char **mem_data = malloc(mem_size * sizeof(char*));

		if (mem_data == NULL || compiled_data == NULL) {
			printf("Main data malloc failed!\n");
			return -1;
		}

		output = processFile(file_name, &compiled_data, &compiled_size, &mem_data, &mem_size, hex, verbose);

		// Measure compile end clock
		clock_t end = clock();
		switch (output.code){
		case ERR_ALLOC:
			printf("Error allocating or reallocating memory at line %d!\n", output.line);
		case ERR_FOPEN:
			printf("Error opening file %s!", output.line_str);
			break;
		case ERR_OK:
			printf("Compiling completed in %.3fs!\n", (double)(end - start)/CLOCKS_PER_SEC);
			break;
		case ERR_SYNTAX:
			printf("File %s: Syntax error at line %d! %s\n", output.file, output.line, output.line_str);
			break;
		case ERR_ILLEGAL_CHAR:
			printf("File %s: Illegal character at line %d!\n", output.file, output.line);
			break;
		case ERR_UNKNOWN_CMD:
			printf("File %s: Unknown command at line %d! %s\n", output.file, output.line, output.line_str);
			break;
		case ERR_UNKNOWN_PARAM:
			printf("File %s: Unknown parameter at line %d!\n", output.file, output.line);
			break;
		case ERR_NO_TEXT_SECT:
			printf("File %s: No text section discovered!\n", output.file);
			break;
		case ERR_UNKNOWN_VAR:
			printf("File %s: Unknown variable at line %d! %s\n", output.file, output.line, output.line_str);
			break;
		case ERR_UNKNOWN_VAR_FORMAT:
			printf("File %s: Unknown variable format at line %d!\n", output.file, output.line);
			break;
		case ERR_UNKNOWN_TAG:
			printf("File %s: Unknown preprocessor tag at line %d! %s\n", output.file, output.line, output.line_str);
			break;
		case ERR_DUPLI_SECTS:
			printf("File %s: Duplicated section at line %d!\n", output.file, output.line);
			break;
		case ERR_DUPLI_VAR:
			printf("File %s: Duplicated variable at line %d\n", output.file, output.line);
			break;
		case ERR_DUPLI_ADDR:
			printf("File %s: Duplicated jump address at line %d\n", output.file, output.line);
			break;
		case ERR_DUPLI_MACRO:
			printf("File %s: Duplicated macro at line %d\n", output.file, output.line);
			break;
		case ERR_INC_PARAM_NUM:
			printf("File %s: Duplicated macro at line %d\n", output.file, output.line);
			break;
		case ERR_MULTI_CON_VAR:
			printf("File %s: Multiple constants or variables at line %d\n", output.file, output.line);
			break;
		default:
			printf("File %s: Unknown Error %d at line %d!\n", output.file, output.code, output.line);
			break;
		}

		if (output.code == 0) {
			// Write compiled data to a file
			start = clock();
			int wrtCode;
			char *fname = NULL;
			char passed = 1;

			// Check if compiled/output file name was supplied
			if (argc > 3 && !verbose && !hex) {
				
			}
			else if(argc > 3){
				unsigned int i;
				for (i = 0; i < ARG_NUM; i++) {
					if (arg_indexes[i] == 3) {
						passed = 0;
						break;
					}
				}
			}
			else {
				passed = 0;
			}

			if (passed) {
				fname = malloc(strlen(args[3]) + 5);// add extension .mif -> 4 chars + NULL
				strcpy(fname, args[3]);
				if (hex) {
					strcat(fname, ".hex");
				}
				else {
					strcat(fname, ".mif");
				}
				//printf("%s\n", fname);
			}
			
			if (hex) {
				wrtCode = generateHEX(fname ? fname : "compiled.hex", compiled_data, output.line, mem_data, output.mem_len, verbose);
			}
			else {
				wrtCode = generateMIF(fname ? fname : "compiled.mif", compiled_data, output.line, mem_data, output.mem_len, verbose);
			}

			if (fname != NULL && passed)free(fname);

			end = clock();

			switch (wrtCode) {
			case 0:
				printf("File succesfully written in %.3fs!\n\n", (double)(end - start) / CLOCKS_PER_SEC);
				printf("%d of %d bytes used(%.2f%% of program memory)\n", output.line, SYS_SIZE, (double)(output.line * 100) / SYS_SIZE);
				if (SYS_MEM == HARVARD) printf("%d of %d bytes used(%.2f%% of data memory)\n", output.mem_len, SYS_SIZE, (double)(output.mem_len * 100) / SYS_SIZE);
				break;
			case -1:
				printf("Error writing to file!");
				break;
			default:
				printf("Unknown file Error!");
				break;
			}
			// Free compiled data
			//unsigned int i;
			//for (i = 0; i < output.line; i++)free(compiled_data[i]);
		}

		// Clear any allocated memory
		if (file_name != NULL) free(file_name);
		if (name != NULL) free(name);
		if (type != NULL) free(type);
		free(compiled_data);
		free(mem_data);

		// Free Loaded System DLL
		unloadSystem();

		return 0;
	}
	printf("Not enough arguments!");
	return -1;
}

static int getFileLength(char *fname) {
	FILE *file;
	char fline[BUF_SIZE];
	unsigned int line_cnt = 0;
	// Open file
	file = fopen(fname, "r");
	if (file == NULL) return -1;
	// Count all lines in a file
	while (fgets(fline, BUF_SIZE, file) != NULL) line_cnt++;
	// Close file
	fclose(file);
	return (int)line_cnt;
}

static int isFileTypeValid(char *file, char *type) {
	const char dot[] = ".";
	volatile char *fname, *ftype;
	char pass = 0;
	char *f = malloc(strlen(file) + 1);
	strcpy(f, file);

	fname = strtok(f, dot);
	if (fname != NULL) {
		ftype = strtok(NULL, "");
		if (ftype != NULL) {
			if (strcmp(ftype, type) == 0) pass = 1;
		}
	}
	// Free any allocated memory
	free(f);
	// Exit
	if (pass) return 0;
	return -1;
}

static out_t processFile(char *file_name, char *** data, unsigned int * data_size, char *** mem, unsigned int * mem_size, char hex, char verbose) {
	FILE *file;
	char **filtered;
	int fsize, fsize_malloc;

	out_t output = {
		.line_str[0] = '\0',
		.code = 0,
		.line = 0,
		.mem_len = 0
	};
	
	// Get file length
	fsize = getFileLength(file_name);
	if(verbose) printf("File length: %d\n", fsize);
	if (fsize == -1) {
		output.code = -1;
		return output;
	}
	// Allocate main file
	filtered = malloc((fsize + 1) * sizeof(char *));

	/*// Read file
	file = fopen(file_name, "r");
	// Check if the file can be read
	if (file == NULL) {
		output.code = -1;
		strcpy(output.line_str, file_name);
		return output;
	}*/
	// Set error scope to main file
	strcpy(output.file, file_name);

	// Process Lines
	char **inc_filt, **tmp;
	char line[BUF_SIZE], compiled[BUF_SIZE];
	int code;
	unsigned int i, j, line_cnt = 0, inst[MAX_INSTS], inst_num;
	char *fline;
	// Address Book
	adr_t adrs[BUF_SIZE];
	unsigned int  adr_cnt = 0;
	// Includes
	char *incs[BUF_SIZE];
	unsigned int inc_num = 0;
	// Macros
	macro_t macros[BUF_SIZE];
	unsigned int macro_num = 0;
	// Variables
	var_t variables[BUF_SIZE];
	unsigned int var_num = 0;
	
	// Stage 1 -> Filter, Preprocess
	output = filterFile(file_name, filtered, incs, &inc_num, macros, &macro_num, verbose);
	if (output.code) {
		free(filtered);
		return output;
	}
	/*while (fgets(line, BUF_SIZE, file) != NULL) {
		processLine(line);

		code = preprocessor(line, incs, &inc_num, macros, &macro_num);
		if (code) {
			output.line = line_cnt + 1;
			output.code = code;
			strcpy(output.line_str, line);
			fclose(file);
			free(filtered);
			return output;
		}
		
		if(verbose) printf("%d: %s\n", line_cnt, line);
		filtered[line_cnt] = malloc(strlen(line) + 1);
		strcpy(filtered[line_cnt], line);

		line_cnt++;
	}
	// Set filtered data end
	filtered[line_cnt] = NULL;
	// Close .asm file
	fclose(file);
	// Reset line counter for Stage 3
	line_cnt = 0;*/
	
	// Stage 2 -> Sections
	sections_t sects = {
		.sec_pos = { -1, -1, -1 }
	};
	sects.sects[SEC_TEXT].index = -1;
	sects.sects[SEC_DATA].index = -1;
	sects.sects[SEC_BSS].index = -1;

	sections_t inc_sects = {
		.sec_pos = { -1, -1, -1 }
	};
	inc_sects.sects[SEC_TEXT].index = -1;
	inc_sects.sects[SEC_DATA].index = -1;
	inc_sects.sects[SEC_BSS].index = -1;

	// Find main file sections
	findSections(&output, filtered, &sects);
	// Return if there was a section error
	if (output.code) {
		free(filtered);
		return output;
	}

	if (verbose) printf("Section indices: %d, %d, %d\n", sects.sects[SEC_TEXT].index, sects.sects[SEC_DATA].index, sects.sects[SEC_BSS].index);
	if (verbose) printf("Section lengths: %d, %d, %d\n", sects.sects[SEC_TEXT].len, sects.sects[SEC_DATA].len, sects.sects[SEC_BSS].len);
	if (verbose) printf("Section positions: %d, %d, %d\n", sects.sec_pos[SEC_TEXT], sects.sec_pos[SEC_DATA], sects.sec_pos[SEC_BSS]);
	if (verbose) printf("Valid sections %d\n", sects.valid_sects);

	// Stage 3 -> Includes
	int inc_fsize;

	if (inc_num) {
		for (i = 0; i < inc_num; i++) {
			// Get file size
			inc_fsize = getFileLength(incs[i]);
			if (inc_fsize == -1) {
				output.code = -1;
				strcpy(output.line_str, incs[i]);
				free(filtered);
				return output;
			}
			// Set error scope to include file
			strcpy(output.file, incs[i]);
			// Allocate file and null termination
			inc_filt = malloc((inc_fsize + 1) * sizeof(char *));
			if (verbose) printf("Include file size: %d\n", inc_fsize);
			// Open file
			file = fopen(incs[i], "r");
			if (file != NULL) {
				// Filter && preprocess file
				out_t inc_out;
				inc_out = filterFile(incs[i], inc_filt, incs, &inc_num, macros, &macro_num, verbose);

				// Find sections
				findSections(&output, inc_filt, &inc_sects);
				// Return if there was a section error
				if (output.code) {
					free(inc_filt);
					free(filtered);
					return output;
				}
				if (verbose) printf("File %s, Section indices: %d, %d, %d\n", incs[i], inc_sects.sects[SEC_TEXT].index, inc_sects.sects[SEC_DATA].index, inc_sects.sects[SEC_BSS].index);
				if (verbose) printf("File %s, Section lengths: %d, %d, %d\n", incs[i], inc_sects.sects[SEC_TEXT].len, inc_sects.sects[SEC_DATA].len, inc_sects.sects[SEC_BSS].len);
				if (verbose) printf("Include valid sections %d\n", inc_sects.valid_sects);

				// Resize filtered data to accommodate new data
				int def_size = fsize;
				while (fsize <= def_size + inc_fsize) {
					fsize *= 1.5;
				}
				//fsize += inc_fsize;
				tmp = realloc(filtered, (fsize + 1) * sizeof(char *));
				if (tmp != NULL) {
					filtered = tmp;
					if (verbose) printf("New file length: %d\n", fsize + 1);
				}
				else {
					output.code = -2;
					free(inc_filt);
					free(filtered);
					return output;
				}

				// Fill realloc with NULL
				for (j = sects.sects[sects.sec_pos[sects.valid_sects - 1]].index + sects.sects[sects.sec_pos[sects.valid_sects - 1]].len + 1; j < fsize; j++) {
					filtered[j] = NULL;
				}

				// Merge sections
				if (mergeSections(&sects, &inc_sects, filtered, inc_filt)) {
					output.code = -2;
					free(inc_filt);
					free(filtered);
					return output;
				}

				// Close include file
				fclose(file);
			}
			else {
				printf("File %s doesn't exist!\n", incs[i]);
				output.code = -1;
			}
			// Free allocated file
			free(inc_filt);
		}
		if (verbose) {
			printf("Files included: %d\n", inc_num);
			while (filtered[line_cnt] != NULL) {
				printf("%d:%s\t%d\n", line_cnt, filtered[line_cnt], strlen(filtered[line_cnt]));
				line_cnt++;
			}
			line_cnt = 0;
		}

		// Rescan file for sections
		findSections(&output, filtered, &sects);
	}
	// Set error scope back to main file
	strcpy(output.file, file_name);
	// The text section must exist!
	if (sects.sects[SEC_TEXT].index > -1) {
		// MEMORY
		if (sects.sects[SEC_DATA].index > -1 || sects.sects[SEC_BSS].index > -1) {
			slot_t mem_slots[BUF_SIZE];
			unsigned int slot_num = 0, mem_pnt = 0;

			// Stage 4 -> Initialized data Section
			if (sects.sects[SEC_DATA].index > -1 && sects.sects[SEC_DATA].len) {
				line_cnt = sects.sects[SEC_DATA].index + 1;
				
				while (filtered[line_cnt] != NULL && !isSection(filtered[line_cnt])) {
					fline = filtered[line_cnt];
					code = processVariable(fline, variables, &var_num, mem_slots, &mem_pnt, &slot_num);
					if (code) {
						output.line = line_cnt;
						output.code = code;
						strcpy(output.line_str, fline);
						free(filtered);
						return output;
					}
					line_cnt++;
				}
				// Debug print all variables
				if (verbose) {
					printf("Number of variables %d\n", var_num);
					for (i = 0; i < var_num; i++) {
						printf("Variable: %s Value: %d Address %d\n", variables[i].name, variables[i].val, variables[i].adr);
					}
				}
			}

			// Stage 5 -> Uninitiallized data Section
			if (sects.sects[SEC_BSS].index > -1 && sects.sects[SEC_BSS].len) {
				line_cnt = sects.sects[SEC_BSS].index + 1;
				/*while (filtered[line_cnt] != NULL && !isSection(filtered[line_cnt])) {
				line_cnt++;
				}*/
			}

			// Set memory length
			output.mem_len = mem_pnt;

			// Stage 6 -> Generate Memory
			if (var_num > 0 && mem_pnt > 0) {
				// Allocate final Memory structure
				unsigned long long *mem_cmpl = NULL, mask = 0;
				mem_cmpl = calloc(mem_pnt, sizeof(long long));
				mask = FILL(SYS_BUS);
				if (verbose) printf("Memory Mask: 0x%llX\n", mask);
				// Write all Variables to the final Memory structure
				for (i = 0; i < var_num; i++) {
					if (variables[i].size == SYS_BUS_BYTE) {
						mem_cmpl[variables[i].adr] = variables[i].val;
					}
					else if (variables[i].size < SYS_BUS_BYTE) {
						// Sloted variables
						mem_cmpl[variables[i].adr] |= ((variables[i].val << (variables[i].slot_pos * 8)) & mask);
					}
					else {
						// Fragmented variables
						for (j = 0; j < variables[i].size / SYS_BUS_BYTE; j++) {
							mem_cmpl[variables[i].adr + j] = ((variables[i].val >> (j * 8)) & mask);
						}
					}
				}
				// Generate Memory
				for (i = 0; i < mem_pnt; i++) {
					if (hex) {
						sprintf(compiled, HEX_LINE, SYS_BUS_BYTE, (SYS_MEM ? i : line_cnt) + SYS_MEM_OFF, HEX_TYPE_DATA, SYS_BUS_BYTE * 2, mem_cmpl[i], hexChecksum(SYS_BUS_BYTE, SYS_MEM ? i : line_cnt, HEX_TYPE_DATA, mem_cmpl[i]));
					}
					else {
						sprintf(compiled, MIF_LINE, (SYS_MEM ? i : line_cnt) + SYS_MEM_OFF, SYS_BUS_BYTE * 2, mem_cmpl[i]);
					}
					if (mem_pnt >= (*mem_size) - 1) {
						printf("Previous size: %d\n", *mem_size);
						(*mem_size) *= 1.5;
						printf("New size: %d\n", *mem_size);
						tmp = realloc(*mem, (*mem_size) * sizeof(char *));
						if (tmp == NULL) {
							output.code = -2;
							free(filtered);
							return output;
						}
						*mem = tmp;
					}
					(*mem)[i] = malloc(strlen(compiled) + 1);
					strcpy((*mem)[i], compiled);
					line_cnt++;
				}

				if (mem_cmpl != NULL)free(mem_cmpl);
			}
		}
		
		// Stage 7 -> Search addresses
		line_cnt = sects.sects[SEC_TEXT].index + 1;
		output.line = 0;
		unsigned int adr_line = 0;

		// Search for addresses
		while (filtered[line_cnt] != NULL && !isSection(filtered[line_cnt])) {
			fline = filtered[line_cnt];
			//printf("%d\n", adr_line);
			// Search for address in line
			code = searchAddress(fline, adr_line, adrs, &adr_cnt);
			if (code) {
				output.line = line_cnt + 1;
				output.code = code;
				strcpy(output.line_str, fline);
				free(filtered);
				return output;
			}
				
			// Get precompile the command to get its length
			code = processCommand(fline, adrs, &adr_cnt, NULL, &inst_num, variables, &var_num, macros, &macro_num);
			if (code) {
				output.line = line_cnt + 1;
				output.code = code;
				strcpy(output.line_str, fline);
				free(filtered);
				return output;
			}
			if(*fline != '\n') adr_line += inst_num;
			
			line_cnt++;
		}
		output.line = 0;

		// Stage 8 -> Text section
		line_cnt = sects.sects[SEC_TEXT].index + 1;
		
		while (filtered[line_cnt] != NULL && !isSection(filtered[line_cnt])) {
			fline = filtered[line_cnt];
			
			if (*fline != '\n') {
				// Process Command
				code = processCommand(fline, adrs, &adr_cnt, inst, &inst_num, variables, &var_num, macros, &macro_num);
				if (code) {
					output.line = line_cnt + 1;
					output.code = code;
					strcpy(output.line_str, fline);
					free(filtered);
					return output;
				}

				for (i = 0; i < inst_num; i++) {
					if (hex) {
						sprintf(compiled, HEX_LINE, SYS_BUS_BYTE, output.line, HEX_TYPE_DATA, SYS_BUS_BYTE * 2, inst[i], hexChecksum(SYS_BUS_BYTE, output.line, HEX_TYPE_DATA, inst[i]));
					}
					else {
						sprintf(compiled, MIF_LINE, output.line, SYS_BUS_BYTE * 2, inst[i]);
					}
					// Resize if the memory buffer is too small
					if (output.line >= (*data_size) - 1) {
						printf("Previous size: %d\n", *data_size);
						(*data_size) *= 1.5;
						printf("New size: %d\n", *data_size);
						tmp = realloc(*data, (*data_size) * sizeof(char *));
						if (tmp == NULL) {
							output.code = -2;
							free(filtered);
							return output;
						}
						*data = tmp;
					}

					(*data)[output.line] = malloc(strlen(compiled) + 1);
					if ((*data)[output.line] == NULL) printf("Malloc failed! %d", output.line);
					strcpy((*data)[output.line], compiled);
					output.line++;
				}
			}
			line_cnt++;
		}
	}
	else {
		// No text section
		output.code = 5;
	}

	// Free filtered data
	free(filtered);

	return output;
}

static out_t filterFile(char * fname, char * output[], char * incs[], unsigned int * inc_num, macro_t * macros, unsigned int * macro_num, char verbose) {
	FILE *file;
	unsigned int line_cnt = 0;
	int code;
	out_t out_data = {
		.line_str[0] = '\0',
		.code = 0,
		.line = 0,
		.mem_len = 0
	};
	char fline[BUF_SIZE];

	// Open file
	file = fopen(fname, "r");
	if (file == NULL) {
		out_data.code = -1;
		strcpy(out_data.line_str, fname);
		return out_data;
	}

	while (fgets(fline, BUF_SIZE, file) != NULL) {
		processLine(fline);

		code = preprocessor(fline, incs, inc_num, macros, macro_num);

		if (code) {
			output[out_data.line] = NULL;
			out_data.line = line_cnt;
			out_data.code = code;
			strcpy(out_data.line_str, fline);
			fclose(file);
			return out_data;
		}
		
		if (verbose) printf("%d: %s\n", out_data.line, fline);
		output[out_data.line] = malloc(strlen(fline) + 1);
		strcpy(output[out_data.line], fline);
		out_data.line++;
		
		line_cnt++;
	}
	// Set filtered data end
	output[out_data.line] = NULL;
	// Close .asm file
	fclose(file);
	return out_data;
}

static void processLine(char *line) {
	// If the line is a newline character, just return
	if (*line == '\n') return;

	unsigned int i;

	// Remove Newline
	if (containsChar(line, '\n')) {
		line[strlen(line) - 1] = '\0';
	}
	
	// Remove comments
	char *semicol;
	semicol = strchr(line, ';');
	if (semicol != NULL) {
		int index;
		index = (int)(semicol - line);

		// Return NULL if the comment is the whole line
		if (index <= 0) {
			// Clear line
			strcpy(line, "\n");
			return;
		}
		// Set null terminator on index otherwise
		line[index] = '\0';
	}

	// Replace tabs with spaces
	if (containsChar(line, '\t')) {
		for (i = 0; i < strlen(line); i++) {
			if (line[i] == '\t') line[i] = ' ';
		}
	}

	if (*line == ' ' && strlen(line) == 1) {
		// Clear line
		strcpy(line, "\n");
		return;
	}

	// Remove all characters up to first 'real' character
	unsigned int index = 0;
	char *tmp = NULL;
	for (i = 0; i < strlen(line); i++) {
		if (line[i] != ' ' && line[i] != '\t') {
			index = i;
			break;
		}
	}
	
	tmp = malloc(strlen(line) + 1);
	for (i = 0; i < strlen(line); i++) {
		if (i >= index) {
			tmp[i - index] = line[i];
		}
		
	}
	tmp[i - index] = '\0';
	strcpy(line, tmp);
	if (tmp != NULL) free(tmp);
}

static int preprocessor(char *line, char *includes[], unsigned int *inc_num, macro_t * macros, unsigned int * macro_num) {
	// Skip preprocessing if the line is empty
	if (*line == '\n') return 0;
	char *tmp = NULL, *tag = NULL, *arg = NULL, *link = NULL, code = 0;
	unsigned int i, j = 0;
	tmp = malloc(strlen(line) + 1);
	strcpy(tmp, line);
	if (containsChar(tmp, '%')) {
		tag = strtok(tmp, " ");
		if (tag != NULL) {
			if (*tag == '%') {
				// Ignore %
				memmove(tag, tag + 1, strlen(tag));
				// Load tag arg
				arg = strtok(NULL, "");
				
				switch (getStringIndex(tag, preproc_tags)) {
				case -1:// Not in array
					code = 7;
					break;
				case 0:// Include
					if (arg != NULL) {
						if (containsChar(arg, '"')) {
							if (*arg == '"' && arg[strlen(arg) - 1] == '"') {
								link = malloc(strlen(arg) - 1);
								// Remove double quotes "
								for (i = 0; i < strlen(arg); i++) {
									if (arg[i] != '"') {
										link[j] = arg[i];
										j++;
									}
								}
								link[j] = '\0';
								// Add link to Includes
								includes[*inc_num] = malloc(strlen(link) + 1);
								strcpy(includes[*inc_num], link);
								free(link);
							}
							else code = 7;
						}
						else {
							// If the link wasn't provided in double quotes, simply use it
							printf("%s\n", arg);
							includes[*inc_num] = malloc(strlen(arg) + 1);
							strcpy(includes[*inc_num], arg);
						}
						(*inc_num)++;
					}
					else code = 7;
					break;

				case 1:// Define
					if (arg != NULL) {
						char *name = strtok(arg, " ");
						char *val = strtok(NULL, "");
						if (name == NULL || val == NULL) {
							code = 7;
							break;
						}
						toLower(name);
						// Check if the macro already exists
						for (i = 0; i < *macro_num; i++) {
							if (strcmp(macros[i].name, name) == 0) {
								code = 12;
								break;
							}
						}
						if (code) break;
						macro_t macro;
						strcpy(macro.name, name);
						if (!strToNum(val, &macro.val)) {
							code = 7;
							break;
						}
						macros[*macro_num] = macro;
						(*macro_num)++;
					}
					else code = 7;
					break;

				default:
					break;
				}
			}
			else code = 7;
		}
		else code = 7;
		if (!code) strcpy(line, "\n");
	}
	
	if (tmp != NULL)free(tmp);
	return code;
}

static int processCommand(char *cmd, adr_t *adrs, unsigned int *adr_num, unsigned int *cmpl, unsigned int *cmpl_num, var_t *vars, unsigned int *var_num, macro_t * macros, unsigned int * macro_num) {
	// If the line is empty, return
	if (*cmd == '\n') return 0;

	unsigned int i;
	
	// Split command and parameters
	char *command = NULL, *cmd_tok = NULL, *params = NULL;
	if (cmd != NULL) {
		command = malloc(strlen(cmd) + 1);
		strcpy(command, cmd);
		cmd_tok = strtok(command, " ");
		if (cmd_tok != NULL) {
			toLower(cmd_tok);
			params = strtok(NULL, "");
		}
		else {
			return 1;
		}
	}
	
	// Check Parameters
	int code;
	char *param_tok = NULL;
	char *paramlist[MAX_PARAMS];
	char tmp[FORMAT_BUF];
	unsigned int param_cnt = 0;
	int indexArray[2] = { -1, -1 };
	char indexFound = 0;

	if (params != NULL) {
		param_tok = strtok(params, ", ");
		while (param_tok != NULL) {
			toLower(param_tok);
			// Check if the parameter is an address
			indexArray[0] = isAddressValid(adrs, *adr_num, param_tok);
			indexArray[1] = isMacroValid(macros, *macro_num, param_tok);
			for (i = 0; i < 2; i++) {
				if (indexArray[i] != -1) {
					switch (i) {
					case 0:
						sprintf(tmp, "0x%02X", adrs[indexArray[i]].adr);
						break;
					case 1:
						sprintf(tmp, "0x%02X", macros[indexArray[i]].val);
						break;
					default:
						break;
					}
					if (i == 0 || i == 1) {
						paramlist[param_cnt] = tmp;
						indexFound = 1;
					}
					break;
				}
			}
			if (!indexFound) {
				paramlist[param_cnt] = param_tok;
			}
			indexFound = 0;
			param_cnt++;
			// Set next parameter
			param_tok = strtok(NULL, ", ");
		}
		// Compile line with parameters
		code = compile(cmd_tok, vars, *var_num, paramlist, param_cnt, cmpl, cmpl_num);
	}
	else {
		// Compile line without parameters
		code = compile(command, vars, *var_num, paramlist, param_cnt, cmpl, cmpl_num);
	}

	// Clear any allocated memory
	if (command != NULL) free(command);

	if (code)return code;
	return 0;
}

static int processVariable(char *line, var_t *vars, unsigned int *var_num, slot_t *slots, unsigned int *mem_pnt, unsigned int *slot_num) {
	// If the line is empty, return
	if (*line == '\n') return 0;

	unsigned int i, j;
	char *tmp = NULL, *name = NULL, *type = NULL, *val = NULL, code = 1;
	tmp = malloc(strlen(line) + 1);
	strcpy(tmp, line);
	name = strtok(tmp, " ");
	toLower(name);
	if (name != NULL) {
		// Check if the variable already exists
		for (i = 0; i < *var_num; i++) {
			if (strcmp(vars[i].name, name) == 0) {
				code = 10;
				break;
			}
		}
		type = strtok(NULL, " ");
		if (type != NULL && code == 1) {
			if (isStringInArray(type, var_types)) {
				val = strtok(NULL, "");
				if (val != NULL) {
					unsigned int elem_num = 0;
					char *element, **elements = NULL;

					if (containsChar(val, ',')) {
						elements = malloc(DEF_SIZE * sizeof(char*));
						// Handle arrays
						element = strtok(val, ", ");
						while (element != NULL) {
							elements[elem_num] = malloc(strlen(element) + 1);
							strcpy(elements[elem_num], element);
							elem_num++;
							element = strtok(NULL, ", ");
						}
					}
					else {
						// Single element was supplied
						elements = malloc(sizeof(char*));
						*elements = malloc(strlen(val) + 1);
						elem_num = 1;
						strcpy(elements[0], val);
					}
					for (j = 0; j < elem_num; j++) {
						// Set Variable Name
						strcpy(vars[*var_num].name, name);
						// Set Variable Size
						vars[*var_num].size = getVarSize(getStringIndex(type, var_types));
						// Find a new variable memory address
						findVarAdr(&vars[*var_num], slots, slot_num, mem_pnt);

						if (countChars(elements[j], '\'') == 2 && *elements[j] == '\'') {
							// Handle strings
							stripChar(elements[j], '\'');
							for (i = 0; i < strlen(elements[j]); i++) {
								if (i > 0) {
									strcpy(vars[*var_num].name, name);
									vars[*var_num].size = getVarSize(getStringIndex(type, var_types));
									findVarAdr(&vars[*var_num], slots, slot_num, mem_pnt);
								}
								vars[*var_num].index = i;
								vars[*var_num].val = elements[j][i];
								(*var_num)++;
							}
							code = 0;
						}
						else {
							// Convert string to integer
							unsigned int num;
							if (strToNum(elements[j], (unsigned int)&num)) {
								// Mask value to prevent overflow
								num &= FILL(vars[*var_num].size * 8);
								// Assign value to variable
								vars[*var_num].index = 0;
								vars[*var_num].val = num;
								(*var_num)++;
								// Variable Succesfully added
								code = 0;
							}
							else {
								// Unknown Variable value
								code = 7;
							}
						}
					}
					if (elements != NULL) free(elements);
				}
			}
			else {
				// Unknown Variable type
				code = 6;
			}
		}
	}
	if (tmp != NULL)free(tmp);
	return code;
}

static int generateMIF(char *fname, char *data[], unsigned int line_num, char *mem[], unsigned int mem_len, char verbose) {
	// Time
	time_t my_time;
	struct tm * tinfo;
	time(&my_time);
	tinfo = localtime(&my_time);

	FILE *file;
	file = fopen(fname, "w");
	if (file == NULL) return -1;
	// Prefix
	fputs(MIF_PREFIX, file);
	fprintf(file, MIF_TIMESTAMP, tinfo->tm_mday, tinfo->tm_mon + 1, 1900 + tinfo->tm_year, tinfo->tm_hour, tinfo->tm_min, tinfo->tm_sec);
	fputc('\n', file);
	fprintf(file, MIF_SETTINGS, SYS_BUS, SYS_SIZE, MIF_RADIX_HEX, MIF_RADIX_HEX);
	fputc('\n', file);

	// Data
	fputs(MIF_START, file);
	unsigned int i;
	if (verbose)printf("%s\n", fname);
	fputs("-- Program\n", file);
	for (i = 0; i < line_num; i++) {
		fputs(data[i], file);
		if (verbose)printf(data[i]);
	}
	if (SYS_MEM == PRINCETON && mem_len) {
		fputs("-- Memory\n", file);
		for (i = 0; i < mem_len; i++) {
			fputs(mem[i], file);
			if (verbose)printf(mem[i]);
		}
		fprintf(file, MIF_INIT_MEM, line_num + mem_len, SYS_SIZE - 1);
	}
	else {
		// If Harvard memory architecture, finish this file
		fprintf(file, MIF_INIT_MEM, line_num, SYS_SIZE - 1);
	}
	fputs(MIF_END, file);
	fclose(file);

	// Write memory content in a separate file if memory architecture is Harvard
	if (SYS_MEM == HARVARD && mem_len) {
		char *fmem = NULL;
		fmem = malloc(strlen(fname) + strlen(FNAME_MEM_EXT) + 1);
		getMemFileName(fname, fmem, MIF);
		if (verbose)printf("%s\n", fmem);
		file = fopen(fmem, "w");
		if (file == NULL) return -1;
		// Prefix
		fputs(MIF_PREFIX, file);
		fprintf(file, MIF_TIMESTAMP, tinfo->tm_mday, tinfo->tm_mon + 1, 1900 + tinfo->tm_year, tinfo->tm_hour, tinfo->tm_min, tinfo->tm_sec);
		fputc('\n', file);
		fprintf(file, MIF_SETTINGS, SYS_BUS, SYS_SIZE, MIF_RADIX_HEX, MIF_RADIX_HEX);
		fputc('\n', file);
		fputs(MIF_START, file);
		fprintf(file, MIF_INIT_MEM, 0, SYS_MEM_OFF - 1);
		for (i = 0; i < mem_len; i++) {
			fputs(mem[i], file);
			if (verbose)printf(mem[i]);
		}
		fprintf(file, MIF_INIT_MEM, mem_len + SYS_MEM_OFF, SYS_SIZE - 1);
		fputs(MIF_END, file);
		if (fmem != NULL)free(fmem);
		fclose(file);
	}
	return 0;
}

static int generateHEX(char *fname, char *data[], unsigned int line_num, char *mem[], unsigned int mem_len, char verbose) {
	FILE *file;
	file = fopen(fname, "w");
	if (file == NULL) return -1;

	// Write all data records
	unsigned int i;
	if (verbose)printf("%s\n", fname);
	for (i = 0; i < line_num; i++) {
		fputs(data[i], file);// \r is appended automaticly
		if (verbose) printf(data[i]);
	}
	if (SYS_MEM == PRINCETON) {
		for (i = 0; i < mem_len; i++) {
			fputs(mem[i], file);
			if (verbose) printf(mem[i]);
		}
	}
	
	// Add termination record
	fputs(HEX_LINE_TERM, file);
	fclose(file);

	if (SYS_MEM == HARVARD && mem_len) {
		char *fmem = NULL;
		fmem = malloc(strlen(fname) + strlen(FNAME_MEM_EXT) + 1);
		getMemFileName(fname, fmem, HEX);
		if (verbose)printf("%s\n", fmem);
		file = fopen(fmem, "w");
		if (file == NULL) return -1;
		for (i = 0; i < mem_len; i++) {
			fputs(mem[i], file);
			if (verbose) printf(mem[i]);
		}
		// Add termination record
		fputs(HEX_LINE_TERM, file);
		if (fmem != NULL) free(fmem);
		fclose(file);
	}
	return 0;
}

static int getMemFileName(char * fname, char *fmemname, char hex) {
	char *tmp = NULL;
	unsigned char index = getCharIndex(fname, '.');
	tmp = malloc(strlen(fname) + strlen(FNAME_MEM_EXT) + 1);
	strcpy(tmp, fname);
	tmp[index] = '\0';
	strcat(tmp, FNAME_MEM_EXT);
	if (hex) {
		strcat(tmp, ".hex");
	}
	else {
		strcat(tmp, ".mif");
	}
	strcpy(fmemname, tmp);
	if (tmp != NULL)free(tmp);
	return 0;
}

static unsigned char hexChecksum(int byteNum, unsigned int address, int type, int data) {
	unsigned int checksum = 0;
	if (type == HEX_TYPE_TERM && byteNum == 0 && address == 0) {
		checksum = 1;
	}
	else {
		checksum = byteNum + address + type + data;
	}
	checksum = ((~checksum) + 1) & 0xFF;
	return (char)checksum;
}

static int searchAddress(char *line, int line_num, adr_t *adrs, unsigned int *adr_book_size) {
	// If the line is empty, return
	if (*line == '\n') return 0;

	unsigned int i;
	// Check for illegal characters
	if (containsAnyChar(line, illegalChars)) return 2;

	// Check for location
	char *colon = strchr(line, ':');
	if (colon != NULL) {
		// If multiple colons are detected, invalidate command
		if (countChars(line, ':') > 1) return 1;

		unsigned int index = (unsigned int)(colon - line);
		char *tmp = NULL, *token = NULL;
		tmp = malloc(strlen(line) + 1);
		strcpy(tmp, line);
		token = strtok(tmp, ":");
		toLower(token);

		// Check if the location already exists
		for (i = 0; i < *adr_book_size; i++) {
			if (strcmp(adrs[i].name, token) == 0) {
				if (tmp != NULL) free(tmp);
				return 11;
			}
		}

		// Add location to address book
		adr_t location;
		location.adr = line_num;
		strcpy(location.name, token);
		adrs[*adr_book_size] = location;
		(*adr_book_size)++;
		//printf("%s\n", location.name);
		
		token = strtok(NULL, ":");
		if (token != NULL) {
			// Check for the rest of the command
			strcpy(line, token);
		}
		else {
			// If there is none, clear the line
			strcpy(line, "\n");
		}
		if (tmp != NULL)free(tmp);
	}
	return 0;
}

static int isAddressValid(adr_t *adr_book, unsigned int adr_book_size, char *address) {
	unsigned int i;
	for (i = 0; i < adr_book_size; i++) {
		if (strcmp(adr_book[i].name, address) == 0) return i;
	}
	return -1;
}

static int isSection(char *line) {
	// If the line is empty, return
	if (*line == '\n') return 0;

	char *tmp = NULL, *sect = NULL, *type = NULL;
	sect = malloc(strlen(line) + 1);
	strcpy(sect, line);
	tmp = strtok(sect, " ");

	if (tmp != NULL && strcmp(tmp, "section") == 0) {
		type = strtok(NULL, "");
		if (type != NULL) {
			if (strcmp(type, ".text") == 0) {
				return 1;
			}
			else if (strcmp(type, ".data") == 0) {
				return 2;
			}
			else if (strcmp(type, ".bss") == 0) {
				return 3;
			}
		}
	}
	if (sect != NULL)free(sect);
	return 0;
}

static int searchSection(char *line, int line_num, sections_t *sects, char *last_sec, unsigned int sec_len, char sec_cnt, char *chk_sects){
	char sec = isSection(line);
	
	if (sec > 0 && sec <= SEC_NUM) {
		// Set section index
		if (!chk_sects[sec - 1]) {
			sects->sects[sec - 1].index = line_num;
			chk_sects[sec - 1] = 1;
		}
		else {
			return 2;
		}
		
		// Set section position in sections
		sects->sec_pos[sec_cnt] = sec - 1;
	}
	else {
		return 0;
	}
	// Set section length
	if (sec_cnt > 0) sects->sects[(*last_sec) - 1].len = sec_len;
	*last_sec = sec;
	
	return 1;
}

static int findSections(out_t *output, char *text[], sections_t *sects) {
	unsigned int line = 0, sec_len = 0;
	char count = 0, last_sec = 0, sec_cnt = 0, chk_sects[SEC_NUM] = { 0 };
	
	while (text[line] != NULL) {
		switch (searchSection(text[line], line, sects, &last_sec, sec_len, sec_cnt, chk_sects)) {
		case 0:
			if (count) sec_len++;
			break;
		case 1:
			if (!count) count = 1;
			else sec_len = 0;
			sec_cnt++;
			break;
		case 2:
			output->code = 8;
			output->line = line;
			return 1;
			break;
		default:
			break;
		}
		line++;
	}
	
	sects->sects[last_sec - 1].len = sec_len;
	sects->valid_sects = sec_cnt;
	return 0;
}

static int mergeSections(sections_t *dest, sections_t *src, char **dest_txt, char **src_txt) {
	char i, sect, **tmp;
	unsigned int j, dest_pnt, src_pnt, dest_size, dest_dspace, src_dspace;

	// Determine dead space before the first function
	dest_dspace = getDeadSpace(dest_txt);
	src_dspace = getDeadSpace(src_txt);

	// Calculate new destination size
	dest_size = 0;
	for (i = 0; i < SEC_NUM; i++) {
		dest_size += dest->sects[i].len;
		dest_size += src->sects[i].len;
	}
	dest_size += dest->valid_sects;
	dest_size += dest_dspace;

	// Iterate through source sections
	for (i = (SEC_NUM - 1); i >= 0; i--) {
		// Get Section
		sect = src->sec_pos[i];

		if (sect > -1) {
			// Add a section to destination if it only exists in source
			if (dest->sects[sect].index <= -1 && src->sects[sect].index > -1 && src->sects[sect].len) {
				// Get source index
				src_pnt = src->sects[sect].index;
				// Get destination index
				dest_pnt = dest->valid_sects + dest->sects[SEC_TEXT].len + dest->sects[SEC_DATA].len + dest->sects[SEC_BSS].len + dest_dspace;
				dest->sects[sect].index = dest_pnt;
				// Add section identifier
				if (dest_txt[dest_pnt] != NULL) {
					tmp = realloc(dest_txt[dest_pnt], strlen(src_txt[src_pnt]) + 1);
					if (tmp == NULL) return -1;
					dest_txt[dest_pnt] = tmp;
				}
				else {
					dest_txt[dest_pnt] = malloc(strlen(src_txt[src_pnt]) + 1);
				}
				strcpy(dest_txt[dest_pnt], src_txt[src_pnt]);
				// Increment valid sections
				dest->valid_sects++;
				dest_size++;
				// Insert section position in first free spot
				for (j = 0; j < SEC_NUM; j++) {
					if (dest->sec_pos[j] <= -1) {
						dest->sec_pos[j] = sect;
						break;
					}
				}
			}
		}
	}

	//printf("Destination\t%d %d %d\n", dest->sec_pos[0], dest->sec_pos[1], dest->sec_pos[2]);
	//printf("Source\t\t%d %d %d\n", src->sec_pos[0], src->sec_pos[1], src->sec_pos[2]);

	// Iterate through destination sections
	for (i = (SEC_NUM - 1); i >= 0; i--) {
		// Get Section
		sect = dest->sec_pos[i];

		if (sect > -1) {
			if (dest->sects[sect].index > -1) {
				if (src->sects[sect].index > -1 && src->sects[sect].len) {
					// Append source section to destination
					dest_pnt = dest->sects[sect].index + dest->sects[sect].len + 1;
					src_pnt = src->sects[sect].index + 1;

					for (j = 0; j < src->sects[sect].len; j++) {
						// Allocate or reallocate place in the destination
						if (dest_txt[dest_pnt + j] != NULL) {
							tmp = realloc(dest_txt[dest_pnt + j], strlen(src_txt[src_pnt + j]) + 1);
							if (tmp == NULL) return -1;
							dest_txt[dest_pnt + j] = tmp;
						}
						else {
							dest_txt[dest_pnt + j] = malloc(strlen(src_txt[src_pnt + j]) + 1);
							if (dest_txt[dest_pnt + j] == NULL) return -1;
						}
						// Copy source line to destination
						strcpy(dest_txt[dest_pnt + j], src_txt[src_pnt + j]);
					}
				}
				// Move the section to the end or the previous section
				if (i > 0) {
					if (i == (dest->valid_sects - 1)) {
						// Set destination pointer to the end of file
						dest_pnt = dest_size - 1;
					}
					else {
						// Set destination pointer just before the last section index
						dest_pnt = dest->sects[dest->sec_pos[i + 1]].index - 1;
					}

					// Set source pointer to the end of the --destination-- section
					src_pnt = dest->sects[sect].index + dest->sects[sect].len + src->sects[sect].len;
					// Copy strings to a new location
					for (j = 0; j <= (src->sects[sect].len + dest->sects[sect].len); j++) {
						// Allocate or reallocate place in the destination
						if (dest_txt[dest_pnt - j] != NULL) {
							tmp = realloc(dest_txt[dest_pnt - j], strlen(dest_txt[src_pnt - j]) + 1);
							if (tmp == NULL) return -1;
							dest_txt[dest_pnt - j] = tmp;
						}
						else {
							dest_txt[dest_pnt - j] = malloc(strlen(dest_txt[src_pnt - j]) + 1);
							if (dest_txt[dest_pnt - j] == NULL) return -1;
						}
						// Copy source line to destination
						strcpy(dest_txt[dest_pnt - j], dest_txt[src_pnt - j]);
					}
					// Set new index for the this section
					dest->sects[sect].index = dest_pnt - (src->sects[sect].len + dest->sects[sect].len);
				}

				// Add source length to destination
				dest->sects[sect].len += src->sects[sect].len;
			}
		}
	}
	return 0;
}

int getDeadSpace(char **text) {
	unsigned int line_cnt = 0;
	while (text[line_cnt] != NULL && !isSection(text[line_cnt])) {
		line_cnt++;
	}
	return line_cnt;
}

static int findVarAdr(var_t *variable, slot_t *slots, unsigned int *slot_num, unsigned int *mem_pnt) {
	//const unsigned char sys = 8;// Debug constant, SYS_BUS_BYTE must be replaced with (sys / 8) for debugging
	unsigned int i;
	// Search for a partially full slot
	for (i = 0; i < *slot_num; i++) {
		// Use a slot
		if (slots[i].space >= variable->size) {
			// Set variable position in the slot
			variable->slot_pos = SYS_BUS_BYTE - slots[i].space;
			// Set slot space
			slots[i].space -= variable->size;
			// Set variable memory address
			variable->adr = slots[i].adr;
			// Return if the slot has been taken
			return 1;
		}
		// Free a slot, if its full or empty
		if ((slots[i].space == 0 || slots[i].space == SYS_BUS_BYTE) && i == ((*slot_num) - 1)) {
			(*slot_num)--;
		}
	}
	
	// If no compatible slots, append to end of memory
	variable->adr = *mem_pnt;
	variable->slot_pos = 0;
	if (variable->size <= SYS_BUS_BYTE) {
		if (variable->size < SYS_BUS_BYTE) {
			// Populate a slot
			slots[*slot_num].adr = *mem_pnt;
			slots[*slot_num].space = SYS_BUS_BYTE - variable->size;
			(*slot_num)++;
		}
		(*mem_pnt)++;
	}
	else {
		(*mem_pnt) += (variable->size / SYS_BUS_BYTE);
	}
	
	return 0;
}

static unsigned char getVarSize(int var_type) {
	switch (var_type) {
	case 0:// DB -> Data Byte
		return 1;
	case 1:// DW -> Data Word
		return 2;
	case 2:// DD -> Double Word
		return 4;
	case 3:// DQ -> Quad Word
		return 8;
	case 4:// DT -> Ten Bytes
		return 10;
	default:
		break;
	}
	return 0;
}

int isMacroValid(macro_t * macros, unsigned int macro_num, char * macro) {
	unsigned int i;
	for (i = 0; i < macro_num; i++) {
		if (strcmp(macros[i].name, macro) == 0) return i;
	}
	return -1;
}
